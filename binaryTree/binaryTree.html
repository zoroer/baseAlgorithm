<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>binaryTree</title>
</head>
<body>

<script type="text/javascript">
    /**
     * 树的节点对象
     * @param data
     * @param left
     * @param right
     * @constructor
     */
    function TreeNode(data, left, right){
        this.data = data;
        this.left = left;
        this.right = right;
        this.show = function (){
            console.log(this.data);
        }
    }

    /**
     * 二叉排序树
     * @constructor
     */
    function BST() {
        this.rootNode = null;
        this.insert = insert;
        this.inOrder = inOrder;
        this.preOrder = preOrder;
        this.lastOrder = lastOrder;
        this.minTree = minTree;
        this.maxTree = maxTree;
        this.searchData = searchData;
    }

    /**
     * 插入数据到二叉排序树中
     * @param data
     */
    function insert(data) {
        let newNode = new TreeNode(data, null, null), currentNode, parentNode;
        if(this.rootNode == null){
            this.rootNode = newNode;
        }else{
            currentNode = this.rootNode;
            while(1){
                parentNode = currentNode;
                if(data < currentNode.data){
                    currentNode = currentNode.left;
                    if(currentNode == null){
                        parentNode.left = newNode;
                        break;
                    }
                }else{
                    currentNode = currentNode.right;
                    if(currentNode == null){
                        parentNode.right = newNode;
                        break;
                    }
                }
            }
        }
    }

    /**
     * 中序遍历
     */
    function inOrder(node) {
        if( node != null ){
            inOrder(node.left);
            node.show(node);
            inOrder(node.right);
        }
    }

    /**
     * 先序遍历
     */
    function preOrder(node) {
        if( node != null ){
            node.show(node);
            preOrder(node.left);
            preOrder(node.right);
        }
    }

    /**
     * 后序遍历
     */
    function lastOrder(node) {
        if( node != null ){
            lastOrder(node.left);
            lastOrder(node.right);
            node.show(node);
        }
    }

    /**
     * 求树的最小值
     * @returns {*}
     */
    function minTree() {
        let currentNode = this.rootNode;
        while( currentNode.left != null ){
            currentNode = currentNode.left;
        }
        console.log("the min data is : " + currentNode.data);
    }

    /**
     * 求树的最大值
     * @returns {*}
     */
    function maxTree() {
        let currentNode = this.rootNode;
        while( currentNode.right != null ){
            currentNode = currentNode.right;
        }
        console.log("the max data is : " + currentNode.data);
    }

    /**
     * 在BST中查找值
     */
    function searchData(data) {
        let currentNode = this.rootNode;
        while( currentNode != null ){
            if(data < currentNode.data){
                currentNode = currentNode.left;
            }else if(data > currentNode.data){
                currentNode = currentNode.right;
            }else{
                console.log(data + " is in BST");
                return currentNode;
            }
        }
        console.log(data + " is not in BST");
    }

    let tree = new BST();
    tree.insert(23);
    tree.insert(45);
    tree.insert(16);
    tree.insert(37);
    tree.insert(3);
    tree.insert(99);
    tree.insert(22);
//    tree.inOrder(tree.rootNode);
//    tree.minTree();
//    tree.maxTree();
    tree.searchData(3);

</script>
</body>
</html>